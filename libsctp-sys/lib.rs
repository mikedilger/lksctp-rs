/* automatically generated by rust-bindgen */
/* and subsequently modified by the author */

#![allow(non_camel_case_types)]
#![allow(raw_pointer_derive)]
#![allow(unstable)]
#![allow(missing_copy_implementations)]

extern crate libc;

/* Socket option layer for SCTP */
pub const SOL_SCTP: i32 = 132;
pub const IPPROTO_SCTP: i32 = 132;

/* The following symbols come from the Sockets API Extensions for
 * SCTP <draft-ietf-tsvwg-sctpsocket-07.txt>.
 */
pub const SCTP_RTOINFO: i32 = 0;
pub const SCTP_ASSOCINFO: i32 = 1;
pub const SCTP_INITMSG: i32 = 2;
pub const SCTP_NODELAY: i32 = 3;                /* Get/set nodelay option. */
pub const SCTP_AUTOCLOSE: i32 = 4;
pub const SCTP_SET_PEER_PRIMARY_ADDR: i32 = 5;
pub const SCTP_PRIMARY_ADDR: i32 = 6;
pub const SCTP_ADAPTATION_LAYER: i32 = 7;
pub const SCTP_DISABLE_FRAGMENTS: i32 = 8;
pub const SCTP_PEER_ADDR_PARAMS: i32 = 9;
pub const SCTP_DEFAULT_SEND_PARAM: i32 = 10;
pub const SCTP_EVENTS: i32 = 11;
pub const SCTP_I_WANT_MAPPED_V4_ADDR: i32 = 12; /* Turn on/off mapped v4 addresses  */
pub const SCTP_MAXSEG: i32 = 13;                /* Get/set maximum fragment. */
pub const SCTP_STATUS: i32 = 14;
pub const SCTP_GET_PEER_ADDR_INFO: i32 = 15;
pub const SCTP_DELAYED_ACK_TIME: i32 = 16;
pub const SCTP_DELAYED_ACK: i32 = SCTP_DELAYED_ACK_TIME;
pub const SCTP_DELAYED_SACK: i32 = SCTP_DELAYED_ACK_TIME;
pub const SCTP_CONTEXT: i32 = 17;
pub const SCTP_FRAGMENT_INTERLEAVE: i32 = 18;
pub const SCTP_PARTIAL_DELIVERY_POINT: i32 = 19;/* Set/Get partial delivery point */
pub const SCTP_MAX_BURST: i32 = 20;             /* Set/Get max burst */
pub const SCTP_AUTH_CHUNK: i32 = 21;            /* Set only: add a chunk type to authenticate */
pub const SCTP_HMAC_IDENT: i32 = 22;
pub const SCTP_AUTH_KEY: i32 = 23;
pub const SCTP_AUTH_ACTIVE_KEY: i32 = 24;
pub const SCTP_AUTH_DELETE_KEY: i32 = 25;
pub const SCTP_PEER_AUTH_CHUNKS: i32 = 26;      /* Read only */
pub const SCTP_LOCAL_AUTH_CHUNKS: i32 = 27;     /* Read only */
pub const SCTP_GET_ASSOC_NUMBER: i32 = 28;      /* Read only */

pub type __u8 = ::libc::c_uchar;
pub type uint8_t = ::libc::c_uchar;
pub type __s32 = ::libc::c_int;
pub type __u32 = ::libc::c_uint;
pub type uint32_t = ::libc::c_uint;
pub type __u64 = ::libc::c_ulong;
pub type __u16 = ::libc::c_ushort;
pub type uint16_t = ::libc::c_ushort;
pub type sa_family_t = ::libc::c_ushort;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_align: ::libc::c_ulong,
    pub __ss_padding: [::libc::c_char; 112us],
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Struct_sockaddr_storage {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type socklen_t = __u32;
pub type size_t = ::libc::c_ulong;
pub type sctp_assoc_t = __s32;

/*
 * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
 *
 *   This cmsghdr structure provides information for initializing new
 *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
 *   uses this same data structure.  This structure is not used for
 *   recvmsg().
 *
 *   cmsg_level    cmsg_type      cmsg_data[]
 *   ------------  ------------   ----------------------
 *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg
 *
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_initmsg {
    pub sinit_num_ostreams: __u16,
    pub sinit_max_instreams: __u16,
    pub sinit_max_attempts: __u16,
    pub sinit_max_init_timeo: __u16,
}
impl ::std::default::Default for Struct_sctp_initmsg {
    fn default() -> Struct_sctp_initmsg { unsafe { ::std::mem::zeroed() } }
}

/*
 * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)
 *
 *   This cmsghdr structure specifies SCTP options for sendmsg() and
 *   describes SCTP header information about a received message through
 *   recvmsg().
 *
 *   cmsg_level    cmsg_type      cmsg_data[]
 *   ------------  ------------   ----------------------
 *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
 *
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_sndrcvinfo {
    pub sinfo_stream: __u16,
    pub sinfo_ssn: __u16,
    pub sinfo_flags: __u16,
    pub sinfo_ppid: __u32,
    pub sinfo_context: __u32,
    pub sinfo_timetolive: __u32,
    pub sinfo_tsn: __u32,
    pub sinfo_cumtsn: __u32,
    pub sinfo_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_sndrcvinfo {
    fn default() -> Struct_sctp_sndrcvinfo { unsafe { ::std::mem::zeroed() } }
}

/*
 *  sinfo_flags: 16 bits (unsigned integer)
 *
 *   This field may contain any of the following flags and is composed of
 *   a bitwise OR of these values.
 */
pub type Enum_sctp_sinfo_flags = ::libc::c_uint;
pub const SCTP_UNORDERED: ::libc::c_uint = 1;  /* Send/receive message unordered. */
pub const SCTP_ADDR_OVER: ::libc::c_uint = 2;  /* Override the primary destination. */
pub const SCTP_ABORT: ::libc::c_uint = 4;      /* Send an ABORT message to the peer. */
pub const SCTP_SACK_IMMEDIATELY: ::libc::c_uint = 8; /* SACK should be sent without delay */
pub const SCTP_EOF: ::libc::c_uint = 512; // MSG_FIN /* Initiate graceful shutdown process. */

#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u32; 8us],
}
impl Union_Unnamed1 {
    pub unsafe fn raw(&mut self) -> *mut __u8 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn init(&mut self) -> *mut Struct_sctp_initmsg {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sndrcv(&mut self) -> *mut Struct_sctp_sndrcvinfo {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Union_Unnamed1 { unsafe { ::std::mem::zeroed() } }
}
pub type sctp_cmsg_data_t = Union_Unnamed1;
pub type Enum_sctp_cmsg_type = ::libc::c_uint;
pub const SCTP_INIT: ::libc::c_uint = 0;   /* 5.2.1 SCTP Initiation Structure */
pub const SCTP_SNDRCV: ::libc::c_uint = 1; /* 5.2.2 SCTP Header Information Structure */
pub type sctp_cmsg_t = Enum_sctp_cmsg_type;

/*
 * 5.3.1.1 SCTP_ASSOC_CHANGE
 *
 *   Communication notifications inform the ULP that an SCTP association
 *   has either begun or ended. The identifier for a new association is
 *   provided by this notificaion. The notification information has the
 *   following format:
 *
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_assoc_change {
    pub sac_type: __u16,
    pub sac_flags: __u16,
    pub sac_length: __u32,
    pub sac_state: __u16,
    pub sac_error: __u16,
    pub sac_outbound_streams: __u16,
    pub sac_inbound_streams: __u16,
    pub sac_assoc_id: sctp_assoc_t,
    pub sac_info: [__u8; 0us],
}
impl ::std::default::Default for Struct_sctp_assoc_change {
    fn default() -> Struct_sctp_assoc_change {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 *   sac_state: 32 bits (signed integer)
 *
 *   This field holds one of a number of values that communicate the
 *   event that happened to the association.  They include:
 *
 *   Note:  The following state names deviate from the API draft as
 *   the names clash too easily with other kernel symbols.
 */
pub type Enum_sctp_sac_state = ::libc::c_uint;
pub const SCTP_COMM_UP: ::libc::c_uint = 0;
pub const SCTP_COMM_LOST: ::libc::c_uint = 1;
pub const SCTP_RESTART: ::libc::c_uint = 2;
pub const SCTP_SHUTDOWN_COMP: ::libc::c_uint = 3;
pub const SCTP_CANT_STR_ASSOC: ::libc::c_uint = 4;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_paddr_change {
    pub spc_type: __u16,
    pub spc_flags: __u16,
    pub spc_length: __u32,
    pub spc_aaddr: Struct_sockaddr_storage,
    pub spc_state: ::libc::c_int,
    pub spc_error: ::libc::c_int,
    pub spc_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_paddr_change {
    fn default() -> Struct_sctp_paddr_change {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 *    spc_state:  32 bits (signed integer)
 *
 *   This field holds one of a number of values that communicate the
 *   event that happened to the address.  They include:
 */
pub type Enum_sctp_spc_state = ::libc::c_uint;
pub const SCTP_ADDR_AVAILABLE: ::libc::c_uint = 0;
pub const SCTP_ADDR_UNREACHABLE: ::libc::c_uint = 1;
pub const SCTP_ADDR_REMOVED: ::libc::c_uint = 2;
pub const SCTP_ADDR_ADDED: ::libc::c_uint = 3;
pub const SCTP_ADDR_MADE_PRIM: ::libc::c_uint = 4;
pub const SCTP_ADDR_CONFIRMED: ::libc::c_uint = 5;

/*
 * 5.3.1.3 SCTP_REMOTE_ERROR
 *
 *   A remote peer may send an Operational Error message to its peer.
 *   This message indicates a variety of error conditions on an
 *   association. The entire error TLV as it appears on the wire is
 *   included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP
 *   specification [SCTP] and any extensions for a list of possible
 *   error formats. SCTP error TLVs have the format:
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_remote_error {
    pub sre_type: __u16,
    pub sre_flags: __u16,
    pub sre_length: __u32,
    pub sre_error: __u16,
    pub sre_assoc_id: sctp_assoc_t,
    pub sre_data: [__u8; 0us],
}
impl ::std::default::Default for Struct_sctp_remote_error {
    fn default() -> Struct_sctp_remote_error {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 5.3.1.4 SCTP_SEND_FAILED
 *
 *   If SCTP cannot deliver a message it may return the message as a
 *   notification.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_send_failed {
    pub ssf_type: __u16,
    pub ssf_flags: __u16,
    pub ssf_length: __u32,
    pub ssf_error: __u32,
    pub ssf_info: Struct_sctp_sndrcvinfo,
    pub ssf_assoc_id: sctp_assoc_t,
    pub ssf_data: [__u8; 0us],
}
impl ::std::default::Default for Struct_sctp_send_failed {
    fn default() -> Struct_sctp_send_failed {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 *   ssf_flags: 16 bits (unsigned integer)
 *
 *   The flag value will take one of the following values
 *
 *   SCTP_DATA_UNSENT  - Indicates that the data was never put on
 *                       the wire.
 *
 *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.
 *                       Note that this does not necessarily mean that the
 *                       data was (or was not) successfully delivered.
 */
pub type Enum_sctp_ssf_flags = ::libc::c_uint;
pub const SCTP_DATA_UNSENT: ::libc::c_uint = 0;
pub const SCTP_DATA_SENT: ::libc::c_uint = 1;

/*
 * 5.3.1.5 SCTP_SHUTDOWN_EVENT
 *
 *   When a peer sends a SHUTDOWN, SCTP delivers this notification to
 *   inform the application that it should cease sending data.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_shutdown_event {
    pub sse_type: __u16,
    pub sse_flags: __u16,
    pub sse_length: __u32,
    pub sse_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_shutdown_event {
    fn default() -> Struct_sctp_shutdown_event {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 5.3.1.6 SCTP_ADAPTATION_INDICATION
 *
 *   When a peer sends a Adaptation Layer Indication parameter , SCTP
 *   delivers this notification to inform the application
 *   that of the peers requested adaptation layer.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_adaptation_event {
    pub sai_type: __u16,
    pub sai_flags: __u16,
    pub sai_length: __u32,
    pub sai_adaptation_ind: __u32,
    pub sai_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_adaptation_event {
    fn default() -> Struct_sctp_adaptation_event {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT
 *
 *   When a receiver is engaged in a partial delivery of a
 *   message this notification will be used to indicate
 *   various events.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_pdapi_event {
    pub pdapi_type: __u16,
    pub pdapi_flags: __u16,
    pub pdapi_length: __u32,
    pub pdapi_indication: __u32,
    pub pdapi_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_pdapi_event {
    fn default() -> Struct_sctp_pdapi_event {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type Enum_Unnamed2 = ::libc::c_uint;
pub const SCTP_PARTIAL_DELIVERY_ABORTED: ::libc::c_uint = 0;

/*
* 5.3.1.8.  SCTP_AUTHENTICATION_EVENT
*
*  When a receiver is using authentication this message will provide
*  notifications regarding new keys being made active as well as errors.
*/
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_authkey_event {
    pub auth_type: __u16,
    pub auth_flags: __u16,
    pub auth_length: __u32,
    pub auth_keynumber: __u16,
    pub auth_altkeynumber: __u16,
    pub auth_indication: __u32,
    pub auth_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_authkey_event {
    fn default() -> Struct_sctp_authkey_event {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type Enum_Unnamed3 = ::libc::c_uint;
pub const SCTP_AUTH_NEWKEY: ::libc::c_uint = 0;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_sender_dry_event {
    pub sender_dry_type: __u16,
    pub sender_dry_flags: __u16,
    pub sender_dry_length: __u32,
    pub sender_dry_assoc_id: sctp_assoc_t,
}
impl ::std::default::Default for Struct_sctp_sender_dry_event {
    fn default() -> Struct_sctp_sender_dry_event {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * Described in Section 7.3
 *   Ancillary Data and Notification Interest Options
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_event_subscribe {
    pub sctp_data_io_event: __u8,
    pub sctp_association_event: __u8,
    pub sctp_address_event: __u8,
    pub sctp_send_failure_event: __u8,
    pub sctp_peer_error_event: __u8,
    pub sctp_shutdown_event: __u8,
    pub sctp_partial_delivery_event: __u8,
    pub sctp_adaptation_layer_event: __u8,
    pub sctp_authentication_event: __u8,
    pub sctp_sender_dry_event: __u8,
}
impl ::std::default::Default for Struct_sctp_event_subscribe {
    fn default() -> Struct_sctp_event_subscribe {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 5.3.1 SCTP Notification Structure
 *
 *   The notification structure is defined as the union of all
 *   notification types.
 *
 */
#[repr(C)]
#[derive(Copy)]
pub struct Union_sctp_notification {
    pub _bindgen_data_: [u32; 37us],
}
impl Union_sctp_notification {
    pub unsafe fn sn_header(&mut self) -> *mut Struct_Unnamed4 {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_assoc_change(&mut self)
     -> *mut Struct_sctp_assoc_change {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_paddr_change(&mut self)
     -> *mut Struct_sctp_paddr_change {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_remote_error(&mut self)
     -> *mut Struct_sctp_remote_error {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_send_failed(&mut self) -> *mut Struct_sctp_send_failed {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_shutdown_event(&mut self)
     -> *mut Struct_sctp_shutdown_event {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_adaptation_event(&mut self)
     -> *mut Struct_sctp_adaptation_event {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_pdapi_event(&mut self) -> *mut Struct_sctp_pdapi_event {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_authkey_event(&mut self)
     -> *mut Struct_sctp_authkey_event {
        ::std::mem::transmute(&self._bindgen_data_)
    }
    pub unsafe fn sn_sender_dry_event(&mut self)
     -> *mut Struct_sctp_sender_dry_event {
        ::std::mem::transmute(&self._bindgen_data_)
    }
}
impl ::std::default::Default for Union_sctp_notification {
    fn default() -> Union_sctp_notification {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub sn_type: __u16,
    pub sn_flags: __u16,
    pub sn_length: __u32,
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Struct_Unnamed4 { unsafe { ::std::mem::zeroed() } }
}

/* Section 5.3.1
 * All standard values for sn_type flags are greater than 2^15.
 * Values from 2^15 and down are reserved.
 */
pub type Enum_sctp_sn_type = ::libc::c_uint;
pub const SCTP_SN_TYPE_BASE: ::libc::c_uint = 32768;
pub const SCTP_ASSOC_CHANGE: ::libc::c_uint = 32769;
pub const SCTP_PEER_ADDR_CHANGE: ::libc::c_uint = 32770;
pub const SCTP_SEND_FAILED: ::libc::c_uint = 32771;
pub const SCTP_REMOTE_ERROR: ::libc::c_uint = 32772;
pub const SCTP_SHUTDOWN_EVENT: ::libc::c_uint = 32773;
pub const SCTP_PARTIAL_DELIVERY_EVENT: ::libc::c_uint = 32774;
pub const SCTP_ADAPTATION_INDICATION: ::libc::c_uint = 32775;
pub const SCTP_AUTHENTICATION_INDICATION: ::libc::c_uint = 32776;
pub const SCTP_SENDER_DRY_EVENT: ::libc::c_uint = 32777;

/* Notification error codes used to fill up the error fields in some
 * notifications.
 * SCTP_PEER_ADDRESS_CHAGE 	: spc_error
 * SCTP_ASSOC_CHANGE		: sac_error
 * These names should be potentially included in the draft 04 of the SCTP
 * sockets API specification.
 */
pub type Enum_sctp_sn_error = ::libc::c_uint;
pub const SCTP_FAILED_THRESHOLD: ::libc::c_uint = 0;
pub const SCTP_RECEIVED_SACK: ::libc::c_uint = 1;
pub const SCTP_HEARTBEAT_SUCCESS: ::libc::c_uint = 2;
pub const SCTP_RESPONSE_TO_USER_REQ: ::libc::c_uint = 3;
pub const SCTP_INTERNAL_ERROR: ::libc::c_uint = 4;
pub const SCTP_SHUTDOWN_GUARD_EXPIRES: ::libc::c_uint = 5;
pub const SCTP_PEER_FAULTY: ::libc::c_uint = 6;
pub type sctp_sn_error_t = Enum_sctp_sn_error;

/*
 * 7.1.1 Retransmission Timeout Parameters (SCTP_RTOINFO)
 *
 *   The protocol parameters used to initialize and bound retransmission
 *   timeout (RTO) are tunable.  See [SCTP] for more information on how
 *   these parameters are used in RTO calculation. 
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_rtoinfo {
    pub srto_assoc_id: sctp_assoc_t,
    pub srto_initial: __u32,
    pub srto_max: __u32,
    pub srto_min: __u32,
}
impl ::std::default::Default for Struct_sctp_rtoinfo {
    fn default() -> Struct_sctp_rtoinfo { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.2 Association Parameters (SCTP_ASSOCINFO)
 *
 *   This option is used to both examine and set various association and
 *   endpoint parameters.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_assocparams {
    pub sasoc_assoc_id: sctp_assoc_t,
    pub sasoc_asocmaxrxt: __u16,
    pub sasoc_number_peer_destinations: __u16,
    pub sasoc_peer_rwnd: __u32,
    pub sasoc_local_rwnd: __u32,
    pub sasoc_cookie_life: __u32,
}
impl ::std::default::Default for Struct_sctp_assocparams {
    fn default() -> Struct_sctp_assocparams {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)
 *
 *  Requests that the peer mark the enclosed address as the association
 *  primary. The enclosed address must be one of the association's
 *  locally bound addresses. The following structure is used to make a
 *   set primary request:
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_setpeerprim {
    pub sspp_assoc_id: sctp_assoc_t,
    pub sspp_addr: Struct_sockaddr_storage,
}
impl ::std::default::Default for Struct_sctp_setpeerprim {
    fn default() -> Struct_sctp_setpeerprim {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)
 *
 *  Requests that the local SCTP stack use the enclosed peer address as
 *  the association primary. The enclosed address must be one of the
 *  association peer's addresses. The following structure is used to
 *  make a set peer primary request:
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_setprim {
    pub ssp_assoc_id: sctp_assoc_t,
    pub ssp_addr: Struct_sockaddr_storage,
}
impl ::std::default::Default for Struct_sctp_setprim {
    fn default() -> Struct_sctp_setprim { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.11 Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)
 *
 * Requests that the local endpoint set the specified Adaptation Layer
 * Indication parameter for all future INIT and INIT-ACK exchanges.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_setadaptation {
    pub ssb_adaptation_ind: __u32,
}
impl ::std::default::Default for Struct_sctp_setadaptation {
    fn default() -> Struct_sctp_setadaptation {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 7.1.13 Peer Address Parameters  (SCTP_PEER_ADDR_PARAMS)
 *
 *   Applications can enable or disable heartbeats for any peer address
 *   of an association, modify an address's heartbeat interval, force a
 *   heartbeat to be sent immediately, and adjust the address's maximum
 *   number of retransmissions sent before an address is considered
 *   unreachable. The following structure is used to access and modify an
 *   address's parameters:
 */
pub type Enum_sctp_spp_flags = ::libc::c_uint;
pub const SPP_HB_ENABLE: ::libc::c_uint = 1;
pub const SPP_HB_DISABLE: ::libc::c_uint = 2;
pub const SPP_HB: ::libc::c_uint = 3;
pub const SPP_HB_DEMAND: ::libc::c_uint = 4;
pub const SPP_PMTUD_ENABLE: ::libc::c_uint = 8;
pub const SPP_PMTUD_DISABLE: ::libc::c_uint = 16;
pub const SPP_PMTUD: ::libc::c_uint = 24;
pub const SPP_SACKDELAY_ENABLE: ::libc::c_uint = 32;
pub const SPP_SACKDELAY_DISABLE: ::libc::c_uint = 64;
pub const SPP_SACKDELAY: ::libc::c_uint = 96;
pub const SPP_HB_TIME_IS_ZERO: ::libc::c_uint = 128;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_paddrparams {
    pub spp_assoc_id: sctp_assoc_t,
    pub spp_address: Struct_sockaddr_storage,
    pub spp_hbinterval: __u32,
    pub spp_pathmaxrxt: __u16,
    pub spp_pathmtu: __u32,
    pub spp_sackdelay: __u32,
    pub spp_flags: __u32,
}
impl ::std::default::Default for Struct_sctp_paddrparams {
    fn default() -> Struct_sctp_paddrparams {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)
 *
 * This set option adds a chunk type that the user is requesting to be
 * received only in an authenticated way.  Changes to the list of chunks
 * will only effect future associations on the socket.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_authchunk {
    pub sauth_chunk: __u8,
}
impl ::std::default::Default for Struct_sctp_authchunk {
    fn default() -> Struct_sctp_authchunk { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)
 *
 * This option gets or sets the list of HMAC algorithms that the local
 * endpoint requires the peer to use.
*/
pub type Enum_Unnamed5 = ::libc::c_uint;
pub const SCTP_AUTH_HMAC_ID_SHA1: ::libc::c_uint = 1;
pub const SCTP_AUTH_HMAC_ID_SHA256: ::libc::c_uint = 3;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_hmacalgo {
    pub shmac_number_of_idents: __u32,
    pub shmac_idents: *mut __u16,
}
impl ::std::default::Default for Struct_sctp_hmacalgo {
    fn default() -> Struct_sctp_hmacalgo { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)
 *
 * This option will set a shared secret key which is used to build an
 * association shared key.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_authkey {
    pub sca_assoc_id: sctp_assoc_t,
    pub sca_keynumber: __u16,
    pub sca_keylength: __u16,
    pub sca_key: *mut __u8,
}
impl ::std::default::Default for Struct_sctp_authkey {
    fn default() -> Struct_sctp_authkey { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)
 *
 * This option will get or set the active shared key to be used to build
 * the association shared key.
 */

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_authkeyid {
    pub scact_assoc_id: sctp_assoc_t,
    pub scact_keynumber: __u16,
}
impl ::std::default::Default for Struct_sctp_authkeyid {
    fn default() -> Struct_sctp_authkeyid { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)
 *
 * This option will effect the way delayed acks are performed.  This
 * option allows you to get or set the delayed ack time, in
 * milliseconds.  It also allows changing the delayed ack frequency.
 * Changing the frequency to 1 disables the delayed sack algorithm.  If
 * the assoc_id is 0, then this sets or gets the endpoints default
 * values.  If the assoc_id field is non-zero, then the set or get
 * effects the specified association for the one to many model (the
 * assoc_id field is ignored by the one to one model).  Note that if
 * sack_delay or sack_freq are 0 when setting this option, then the
 * current values will remain unchanged.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_sack_info {
    pub sack_assoc_id: sctp_assoc_t,
    pub sack_delay: uint32_t,
    pub sack_freq: uint32_t,
}
impl ::std::default::Default for Struct_sctp_sack_info {
    fn default() -> Struct_sctp_sack_info { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_assoc_value {
    pub assoc_id: sctp_assoc_t,
    pub assoc_value: uint32_t,
}
impl ::std::default::Default for Struct_sctp_assoc_value {
    fn default() -> Struct_sctp_assoc_value {
        unsafe { ::std::mem::zeroed() }
    }
}

/*
 * 7.2.2 Peer Address Information
 *
 *   Applications can retrieve information about a specific peer address
 *   of an association, including its reachability state, congestion
 *   window, and retransmission timer values.  This information is
 *   read-only. The following structure is used to access this
 *   information:
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_paddrinfo {
    pub spinfo_assoc_id: sctp_assoc_t,
    pub spinfo_address: Struct_sockaddr_storage,
    pub spinfo_state: __s32,
    pub spinfo_cwnd: __u32,
    pub spinfo_srtt: __u32,
    pub spinfo_rto: __u32,
    pub spinfo_mtu: __u32,
}
impl ::std::default::Default for Struct_sctp_paddrinfo {
    fn default() -> Struct_sctp_paddrinfo { unsafe { ::std::mem::zeroed() } }
}

/* Peer addresses's state. */
/* UNKNOWN: Peer address passed by the upper layer in sendmsg or connect[x]
 * calls.
 * UNCONFIRMED: Peer address received in INIT/INIT-ACK address parameters.
 *              Not yet confirmed by a heartbeat and not available for data
 *		transfers.
 * ACTIVE : Peer address confirmed, active and available for data transfers.
 * INACTIVE: Peer address inactive and not available for data transfers.
 */
pub type Enum_sctp_spinfo_state = ::libc::c_uint;
pub const SCTP_INACTIVE: ::libc::c_uint = 0;
pub const SCTP_ACTIVE: ::libc::c_uint = 1;
pub const SCTP_UNCONFIRMED: ::libc::c_uint = 2;

/*
 * 7.2.1 Association Status (SCTP_STATUS)
 *
 *   Applications can retrieve current status information about an
 *   association, including association state, peer receiver window size,
 *   number of unacked data chunks, and number of data chunks pending
 *   receipt.  This information is read-only.  The following structure is
 *   used to access this information:
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_status {
    pub sstat_assoc_id: sctp_assoc_t,
    pub sstat_state: __s32,
    pub sstat_rwnd: __u32,
    pub sstat_unackdata: __u16,
    pub sstat_penddata: __u16,
    pub sstat_instrms: __u16,
    pub sstat_outstrms: __u16,
    pub sstat_fragmentation_point: __u32,
    pub sstat_primary: Struct_sctp_paddrinfo,
}
impl ::std::default::Default for Struct_sctp_status {
    fn default() -> Struct_sctp_status { unsafe { ::std::mem::zeroed() } }
}

/*
 * 7.2.3.  Get the list of chunks the peer requires to be authenticated
 *         (SCTP_PEER_AUTH_CHUNKS)
 *
 * This option gets a list of chunks for a specified association that
 * the peer requires to be received authenticated only.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_authchunks {
    pub gauth_assoc_id: sctp_assoc_t,
    pub gauth_number_of_chunks: __u32,
    pub gauth_chunks: *mut uint8_t,
}
impl ::std::default::Default for Struct_sctp_authchunks {
    fn default() -> Struct_sctp_authchunks { unsafe { ::std::mem::zeroed() } }
}

/* Association states.  */
pub type Enum_sctp_sstat_state = ::libc::c_uint;
pub const SCTP_EMPTY: ::libc::c_uint = 0;
pub const SCTP_CLOSED: ::libc::c_uint = 1;
pub const SCTP_COOKIE_WAIT: ::libc::c_uint = 2;
pub const SCTP_COOKIE_ECHOED: ::libc::c_uint = 3;
pub const SCTP_ESTABLISHED: ::libc::c_uint = 4;
pub const SCTP_SHUTDOWN_PENDING: ::libc::c_uint = 5;
pub const SCTP_SHUTDOWN_SENT: ::libc::c_uint = 6;
pub const SCTP_SHUTDOWN_RECEIVED: ::libc::c_uint = 7;
pub const SCTP_SHUTDOWN_ACK_SENT: ::libc::c_uint = 8;
pub enum Struct_sockaddr { }

/*
 * 8.3, 8.5 get all peer/local addresses in an association.
 * This parameter struct is used by SCTP_GET_PEER_ADDRS and
 * SCTP_GET_LOCAL_ADDRS socket options used internally to implement
 * sctp_getpaddrs() and sctp_getladdrs() API.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_getaddrs_old {
    pub assoc_id: sctp_assoc_t,
    pub addr_num: ::libc::c_int,
    pub addrs: *mut Struct_sockaddr,
}
impl ::std::default::Default for Struct_sctp_getaddrs_old {
    fn default() -> Struct_sctp_getaddrs_old {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_getaddrs {
    pub assoc_id: sctp_assoc_t,
    pub addr_num: __u32,
    pub addrs: [__u8; 0us],
}
impl ::std::default::Default for Struct_sctp_getaddrs {
    fn default() -> Struct_sctp_getaddrs { unsafe { ::std::mem::zeroed() } }
}

/* A socket user request obtained via SCTP_GET_ASSOC_STATS that retrieves
 * association stats. All stats are counts except sas_maxrto and
 * sas_obs_rto_ipaddr. maxrto is the max observed rto + transport since
 * the last call. Will return 0 when did not change since last call
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sctp_assoc_stats {
    pub sas_assoc_id: sctp_assoc_t,
    pub sas_obs_rto_ipaddr: Struct_sockaddr_storage,
    pub sas_maxrto: __u64,
    pub sas_isacks: __u64,
    pub sas_osacks: __u64,
    pub sas_opackets: __u64,
    pub sas_ipackets: __u64,
    pub sas_rtxchunks: __u64,
    pub sas_outofseqtsns: __u64,
    pub sas_idupchunks: __u64,
    pub sas_gapcnt: __u64,
    pub sas_ouodchunks: __u64,
    pub sas_iuodchunks: __u64,
    pub sas_oodchunks: __u64,
    pub sas_iodchunks: __u64,
    pub sas_octrlchunks: __u64,
    pub sas_ictrlchunks: __u64,
}
impl ::std::default::Default for Struct_sctp_assoc_stats {
    fn default() -> Struct_sctp_assoc_stats {
        unsafe { ::std::mem::zeroed() }
    }
}

/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
/* On user space Linux, these live in <bits/socket.h> as an enum.  */
pub type Enum_sctp_msg_flags = ::libc::c_uint;
pub const MSG_NOTIFICATION: ::libc::c_uint = 32768;

/*
 * 8.1 sctp_bindx()
 *
 * The flags parameter is formed from the bitwise OR of zero or more of the
 * following currently defined flags:
 */
pub const SCTP_BINDX_ADD_ADDR: ::libc::c_uint = 0x01;
pub const SCTP_BINDX_REM_ADDR: ::libc::c_uint = 0x02;

/* This is the structure that is passed as an argument(optval) to
 * getsockopt(SCTP_SOCKOPT_PEELOFF).
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub associd: sctp_assoc_t,
    pub sd: ::libc::c_int,
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Struct_Unnamed6 { unsafe { ::std::mem::zeroed() } }
}
pub type sctp_peeloff_arg_t = Struct_Unnamed6;

#[link(name = "sctp")]
extern "C" {
    pub fn sctp_bindx(sd: ::libc::c_int, addrs: *mut Struct_sockaddr,
                      addrcnt: ::libc::c_int, flags: ::libc::c_int)
                      -> ::libc::c_int;

    pub fn sctp_connectx(sd: ::libc::c_int, addrs: *mut Struct_sockaddr,
                         addrcnt: ::libc::c_int, id: *mut sctp_assoc_t)
                         -> ::libc::c_int;

    pub fn sctp_peeloff(sd: ::libc::c_int, assoc_id: sctp_assoc_t)
                        -> ::libc::c_int;

    /* Prototype for the library function sctp_opt_info defined in
     * API 7. Socket Options.
     */
    pub fn sctp_opt_info(sd: ::libc::c_int, id: sctp_assoc_t,
                         opt: ::libc::c_int, arg: *mut ::libc::c_void,
                         size: *mut socklen_t) -> ::libc::c_int;

    /* Get all peer address on a socket.  This is a new SCTP API
     * described in the section 8.3 of the Sockets API Extensions for SCTP.
     * This is implemented using the getsockopt() interface.
     */
    pub fn sctp_getpaddrs(sd: ::libc::c_int, id: sctp_assoc_t,
                          addrs: *mut *mut Struct_sockaddr) -> ::libc::c_int;

    /* Frees all resources allocated by sctp_getpaddrs().  This is a new SCTP API
     * described in the section 8.4 of the Sockets API Extensions for SCTP.
     */
    pub fn sctp_freepaddrs(addrs: *mut Struct_sockaddr) -> ::libc::c_int;

    /* Get all locally bound address on a socket.  This is a new SCTP API
     * described in the section 8.5 of the Sockets API Extensions for SCTP.
     * This is implemented using the getsockopt() interface.
     */
    pub fn sctp_getladdrs(sd: ::libc::c_int, id: sctp_assoc_t,
                          addrs: *mut *mut Struct_sockaddr) -> ::libc::c_int;

    /* Frees all resources allocated by sctp_getladdrs().  This is a new SCTP API
     * described in the section 8.6 of the Sockets API Extensions for SCTP.
     */
    pub fn sctp_freeladdrs(addrs: *mut Struct_sockaddr) -> ::libc::c_int;

    /* This library function assists the user with the advanced features
     * of SCTP.  This is a new SCTP API described in the section 8.7 of the
     * Sockets API Extensions for SCTP. This is implemented using the
     * sendmsg() interface.
     */
    pub fn sctp_sendmsg(s: ::libc::c_int, msg: *const ::libc::c_void,
                        len: size_t, to: *mut Struct_sockaddr,
                        tolen: socklen_t, ppid: uint32_t, flags: uint32_t,
                        stream_no: uint16_t, timetolive: uint32_t,
                        context: uint32_t) -> ::libc::c_int;

    /* This library function assist the user with sending a message without
     * dealing directly with the CMSG header.
     */
    pub fn sctp_send(s: ::libc::c_int, msg: *const ::libc::c_void,
                     len: size_t, sinfo: *const Struct_sctp_sndrcvinfo,
                     flags: ::libc::c_int) -> ::libc::c_int;

    /* This library function assists the user with the advanced features
     * of SCTP.  This is a new SCTP API described in the section 8.8 of the
     * Sockets API Extensions for SCTP. This is implemented using the
     * recvmsg() interface.
     */
    pub fn sctp_recvmsg(s: ::libc::c_int, msg: *mut ::libc::c_void,
                        len: size_t, from: *mut Struct_sockaddr,
                        fromlen: *mut socklen_t,
                        sinfo: *mut Struct_sctp_sndrcvinfo,
                        msg_flags: *mut ::libc::c_int) -> ::libc::c_int;

    /* Return the address length for an address family. */
    pub fn sctp_getaddrlen(family: sa_family_t) -> ::libc::c_int;
}
